# Implementation Plan: E2E Wiring

**Date:** 2026-02-20
**Design:** `docs/designs/2026-02-20-e2e-wiring.md`
**Feature ID:** `e2e-wiring`

## Task Summary

| ID | Title | Phase | Parallel Group | Dependencies |
|----|-------|-------|---------------|-------------|
| 1 | Intelligence: Generic policy builder | RED→GREEN | A (Python) | None |
| 2 | Intelligence: Analyze endpoint fallback | RED→GREEN | A (Python) | 1 |
| 3 | Gateway: AnalyzeRequestDto serialization | RED→GREEN | B (C#) | None |
| 4 | Gateway: IntelligenceClient HTTP implementation | RED→GREEN | B (C#) | 3 |
| 5 | Gateway: DI wiring for HttpClient | RED→GREEN | B (C#) | 4 |
| 6 | Gateway: MockDataService analysis update | RED→GREEN | C (C#) | None |
| 7 | Gateway: ProcessPARequest mutation wiring | RED→GREEN | D (C#) | 5, 6 |
| 8 | Gateway: ProcessPARequest error handling | RED→GREEN | D (C#) | 7 |
| 9 | Gateway: Integration tests (Alba) | RED→GREEN | E (C#) | 7 |
| 10 | Dashboard: Component tests for real data shapes | RED→GREEN | F (TS) | None |

## Parallelization Strategy

```
Group A (Python worktree)     Group B (C# worktree)     Group C (C# worktree)     Group F (TS worktree)
┌──────────────────────┐     ┌──────────────────────┐   ┌──────────────────────┐   ┌──────────────────────┐
│ Task 1: Generic      │     │ Task 3: Request DTO  │   │ Task 6: MockData     │   │ Task 10: Dashboard   │
│   policy builder     │     │   serialization      │   │   analysis update    │   │   component tests    │
│         │            │     │         │            │   │                      │   │                      │
│         ▼            │     │         ▼            │   └──────────────────────┘   └──────────────────────┘
│ Task 2: Analyze      │     │ Task 4: HTTP client  │
│   endpoint fallback  │     │   implementation     │
│                      │     │         │            │
└──────────────────────┘     │         ▼            │
                             │ Task 5: DI wiring    │
                             │                      │
                             └──────────────────────┘
                                       │
                    ┌──────────────────┤◄─── Group C merges
                    ▼
              Group D (C# - sequential on main)
              ┌──────────────────────┐
              │ Task 7: ProcessPA    │
              │   mutation wiring    │
              │         │            │
              │         ▼            │
              │ Task 8: Error        │
              │   handling           │
              └──────────────────────┘
                        │
                        ▼
              Group E (C# - integration)
              ┌──────────────────────┐
              │ Task 9: Alba         │
              │   integration tests  │
              └──────────────────────┘
```

**Groups A, B, C, F** run in parallel worktrees.
**Group D** runs after B+C merge to main.
**Group E** runs after D + A merge.

---

## Task Details

### Task 1: Intelligence — Generic Policy Builder
**Phase:** RED → GREEN
**Parallel Group:** A (Python worktree)
**Dependencies:** None

1. **[RED]** Write tests for generic policy builder
   - File: `apps/intelligence/src/tests/test_generic_policy.py`
   - Tests:
     - `test_build_generic_policy_returns_valid_structure` — Policy has required keys: policy_id, criteria, form_field_mappings
     - `test_build_generic_policy_includes_medical_necessity_criterion` — Generic policy always includes medical necessity
     - `test_build_generic_policy_includes_diagnosis_criterion` — Generic policy always includes diagnosis validation
     - `test_build_generic_policy_uses_procedure_code` — Procedure code is set in the policy
   - Expected failure: `ModuleNotFoundError` — `generic_policy` module doesn't exist

2. **[GREEN]** Implement generic policy builder
   - File: `apps/intelligence/src/policies/generic_policy.py`
   - Create `build_generic_policy(procedure_code: str) -> dict[str, Any]`
   - Generic criteria:
     - `medical_necessity` — "Medical necessity documented for the requested procedure"
     - `diagnosis_present` — "Valid ICD-10 diagnosis code present"
     - `clinical_documentation` — "Clinical documentation supports the request"
   - Returns policy dict matching `EXAMPLE_POLICY` structure

3. **[REFACTOR]** Extract shared policy structure constants if needed

---

### Task 2: Intelligence — Analyze Endpoint Fallback
**Phase:** RED → GREEN
**Parallel Group:** A (Python worktree)
**Dependencies:** Task 1

1. **[RED]** Write tests for analyze endpoint with unsupported procedure codes
   - File: `apps/intelligence/src/tests/test_analyze.py` (expand existing)
   - Tests:
     - `test_analyze_unsupported_procedure_uses_generic_policy` — POST /analyze with procedure_code="27447" (TKR) returns 200, not 400
     - `test_analyze_generic_policy_returns_valid_response` — Response has all PAFormResponse fields populated
     - `test_analyze_generic_policy_includes_evidence` — `supporting_evidence` list is non-empty
     - `test_analyze_known_procedure_still_uses_specific_policy` — POST /analyze with "72148" still uses MRI policy (regression guard)
   - Expected failure: `HTTPException 400` — current code rejects unsupported procedures
   - Mock pattern: Patch `src.reasoning.evidence_extractor.chat_completion` and `src.reasoning.form_generator.chat_completion` with `AsyncMock`

2. **[GREEN]** Update analyze endpoint
   - File: `apps/intelligence/src/api/analyze.py`
   - Remove the hard 400 rejection for unsupported procedures
   - Import `build_generic_policy` from `src.policies.generic_policy`
   - Logic:
     ```python
     if request.procedure_code in SUPPORTED_PROCEDURE_CODES:
         policy = {**EXAMPLE_POLICY, "procedure_codes": [request.procedure_code]}
     else:
         policy = build_generic_policy(request.procedure_code)
     ```
   - Same change in `analyze_with_documents` endpoint

3. **[REFACTOR]** Extract policy resolution into helper function `resolve_policy(procedure_code: str) -> dict`

---

### Task 3: Gateway — AnalyzeRequestDto Serialization
**Phase:** RED → GREEN
**Parallel Group:** B (C# worktree)
**Dependencies:** None

1. **[RED]** Write serialization tests
   - File: `apps/gateway/Gateway.API.Tests/Services/IntelligenceClientSerializationTests.cs`
   - Tests:
     - `BuildAnalyzeRequest_MapsPatientFullName_ToNameField` — `ClinicalBundle.Patient.FullName` → `clinical_data.patient.name`
     - `BuildAnalyzeRequest_MapsPatientBirthDate_ToIsoString` — `DateOnly(1968,3,15)` → `"1968-03-15"`
     - `BuildAnalyzeRequest_MapsConditions_ToSnakeCaseKeys` — `ConditionInfo.ClinicalStatus` → `clinical_status`
     - `BuildAnalyzeRequest_MapsObservations_WithAllFields` — code, display, value, unit all present
     - `BuildAnalyzeRequest_WithNullPatient_SetsNullPatientField` — handles missing patient gracefully
     - `SerializeRequest_UsesSnakeCaseNaming` — JSON output has `patient_id`, `procedure_code`, `clinical_data` keys
   - Expected failure: `AnalyzeRequestDto` class doesn't exist

2. **[GREEN]** Implement AnalyzeRequestDto and mapping
   - File: `apps/gateway/Gateway.API/Services/IntelligenceClient.cs` (internal DTOs)
   - Create internal request DTOs:
     ```csharp
     internal sealed record AnalyzeRequestDto(string PatientId, string ProcedureCode, ClinicalDataDto ClinicalData);
     internal sealed record ClinicalDataDto(PatientDto? Patient, List<ConditionDto> Conditions, ...);
     internal sealed record PatientDto(string Name, string? BirthDate, string? Gender, string? MemberId);
     internal sealed record ConditionDto(string Code, string? System, string? Display, string? ClinicalStatus);
     // etc.
     ```
   - Static `JsonSerializerOptions` with `JsonNamingPolicy.SnakeCaseLower`
   - Static `BuildAnalyzeRequest(ClinicalBundle, string procedureCode)` method that maps C# models → DTOs

3. **[REFACTOR]** Ensure DTOs are `internal` and only visible to tests via `InternalsVisibleTo`

---

### Task 4: Gateway — IntelligenceClient HTTP Implementation
**Phase:** RED → GREEN
**Parallel Group:** B (C# worktree)
**Dependencies:** Task 3

1. **[RED]** Write HTTP client tests
   - File: `apps/gateway/Gateway.API.Tests/Services/IntelligenceClientTests.cs`
   - Tests (using `MockHttpMessageHandler` pattern or `HttpClient` with test handler):
     - `AnalyzeAsync_PostsToAnalyzeEndpoint_WithCorrectPayload` — Verifies POST to `/api/analyze` with snake_case JSON
     - `AnalyzeAsync_DeserializesResponse_ToPAFormData` — Mock 200 response with snake_case JSON → correct PAFormData
     - `AnalyzeAsync_WhenServiceReturns400_ThrowsHttpRequestException` — Mock 400 → exception
     - `AnalyzeAsync_WhenServiceReturns500_ThrowsHttpRequestException` — Mock 500 → exception
     - `AnalyzeAsync_LogsRequestAndResponse` — Verify logger calls
   - Expected failure: `IntelligenceClient` constructor expects `ILogger` only, not `HttpClient`
   - Mock pattern: Create `HttpClient` with a `DelegatingHandler` that captures and returns canned responses

2. **[GREEN]** Replace stub IntelligenceClient with HTTP implementation
   - File: `apps/gateway/Gateway.API/Services/IntelligenceClient.cs`
   - Replace constructor: `(ILogger<IntelligenceClient> logger)` → `(HttpClient httpClient, ILogger<IntelligenceClient> logger)`
   - Replace `AnalyzeAsync`:
     ```csharp
     public async Task<PAFormData> AnalyzeAsync(ClinicalBundle bundle, string procedureCode, CancellationToken ct)
     {
         var request = BuildAnalyzeRequest(bundle, procedureCode);
         _logger.LogInformation("Calling Intelligence service for ProcedureCode={ProcedureCode}", procedureCode);
         var response = await _httpClient.PostAsJsonAsync("/api/analyze", request, SnakeCaseSerializerOptions, ct);
         response.EnsureSuccessStatusCode();
         var result = await response.Content.ReadFromJsonAsync<PAFormData>(cancellationToken: ct);
         _logger.LogInformation("Intelligence response: Recommendation={Recommendation}, Confidence={Confidence}",
             result!.Recommendation, result.ConfidenceScore);
         return result;
     }
     ```
   - Note: `PAFormData` already has `[JsonPropertyName]` attributes for deserialization

3. **[REFACTOR]** Clean up removed stub code

---

### Task 5: Gateway — DI Wiring for HttpClient
**Phase:** RED → GREEN
**Parallel Group:** B (C# worktree)
**Dependencies:** Task 4

1. **[RED]** Write DI registration test
   - File: `apps/gateway/Gateway.API.Tests/DependencyExtensionsTests.cs` (expand existing)
   - Tests:
     - `AddIntelligenceClient_RegistersHttpClientForIntelligenceClient` — Resolve `IIntelligenceClient` from DI; verify it's backed by `HttpClient` (not the old parameterless constructor)
     - `AddIntelligenceClient_ConfiguresBaseUrlFromOptions` — Verify `HttpClient.BaseAddress` matches `IntelligenceOptions.BaseUrl`
     - `AddIntelligenceClient_AppliesCachingDecorator` — Resolved `IIntelligenceClient` is `CachingIntelligenceClient`
   - Expected failure: DI still registers stub without `HttpClient`

2. **[GREEN]** Update DependencyExtensions
   - File: `apps/gateway/Gateway.API/DependencyExtensions.cs`
   - Replace in `AddIntelligenceClient()`:
     ```csharp
     services.AddOptions<IntelligenceOptions>()
         .BindConfiguration(IntelligenceOptions.SectionName)
         .Validate(o => !string.IsNullOrEmpty(o.BaseUrl), "Intelligence BaseUrl is required");

     services.AddHttpClient<IIntelligenceClient, IntelligenceClient>()
         .ConfigureHttpClient((sp, client) =>
         {
             var options = sp.GetRequiredService<IOptions<IntelligenceOptions>>().Value;
             client.BaseAddress = new Uri(options.BaseUrl);
             client.Timeout = TimeSpan.FromSeconds(options.TimeoutSeconds);
         });
     ```
   - Caching decorator registration (`services.Decorate`) stays the same

3. **[REFACTOR]** Remove STUB comments from DependencyExtensions

---

### Task 6: Gateway — MockDataService Analysis Update
**Phase:** RED → GREEN
**Parallel Group:** C (C# worktree)
**Dependencies:** None

1. **[RED]** Write tests for extended UpdatePARequest
   - File: `apps/gateway/Gateway.API.Tests/Services/MockDataServiceTests.cs` (new or expand)
   - Tests:
     - `ApplyAnalysisResult_UpdatesStatus_ToReady` — After call, PA request status is "ready"
     - `ApplyAnalysisResult_UpdatesConfidence_FromScore` — Confidence reflects provided value
     - `ApplyAnalysisResult_UpdatesClinicalSummary` — ClinicalSummary is set from Intelligence response
     - `ApplyAnalysisResult_UpdatesCriteria_FromEvidence` — Criteria list matches provided evidence items
     - `ApplyAnalysisResult_SetsReadyAtTimestamp` — ReadyAt is set to current time
     - `ApplyAnalysisResult_NonExistentId_ReturnsNull` — Returns null for unknown ID
   - Expected failure: No `ApplyAnalysisResult` method exists

2. **[GREEN]** Add analysis result method to MockDataService
   - File: `apps/gateway/Gateway.API/Services/MockDataService.cs`
   - Add new method:
     ```csharp
     public PARequestModel? ApplyAnalysisResult(
         string id,
         string clinicalSummary,
         int confidence,
         IReadOnlyList<CriterionModel> criteria)
     ```
   - Inside lock: find request, update status="ready", confidence, clinicalSummary, criteria, readyAt=now, updatedAt=now
   - Return updated model or null

3. **[REFACTOR]** Consider whether old `ProcessPARequestAsync` should be removed or kept for fallback

---

### Task 7: Gateway — ProcessPARequest Mutation Wiring
**Phase:** RED → GREEN
**Parallel Group:** D (sequential, after B+C merge)
**Dependencies:** Tasks 5, 6

1. **[RED]** Write mutation wiring tests
   - File: `apps/gateway/Gateway.API.Tests/GraphQL/ProcessPARequestMutationTests.cs`
   - Pattern: Unit test with NSubstitute mocks for `IFhirDataAggregator`, `IIntelligenceClient`, `MockDataService`
   - Tests:
     - `ProcessPARequest_CallsFhirAggregator_WithPatientId` — Verifies `AggregateClinicalDataAsync` called with correct patient ID from PA request
     - `ProcessPARequest_CallsIntelligenceClient_WithBundleAndProcedureCode` — Verifies `AnalyzeAsync` called with aggregated bundle and PA request's procedure code
     - `ProcessPARequest_MapsEvidenceToMet_WhenStatusIsMET` — Evidence with Status="MET" maps to `CriterionModel.Met=true`
     - `ProcessPARequest_MapsEvidenceToNotMet_WhenStatusIsNOT_MET` — Status="NOT_MET" maps to `Met=false`
     - `ProcessPARequest_MapsEvidenceToNull_WhenStatusIsUNCLEAR` — Status="UNCLEAR" maps to `Met=null`
     - `ProcessPARequest_SetsConfidence_FromScoreTimes100` — `ConfidenceScore=0.85` → `Confidence=85`
     - `ProcessPARequest_ReturnsNull_WhenPARequestNotFound` — Returns null for unknown ID
   - Expected failure: `ProcessPARequest` still only takes `MockDataService` parameter

2. **[GREEN]** Wire ProcessPARequest mutation
   - File: `apps/gateway/Gateway.API/GraphQL/Mutations/Mutation.cs`
   - Replace `ProcessPARequest`:
     ```csharp
     public async Task<PARequestModel?> ProcessPARequest(
         string id,
         [Service] MockDataService mockData,
         [Service] IFhirDataAggregator fhirAggregator,
         [Service] IIntelligenceClient intelligenceClient,
         CancellationToken ct)
     {
         var paRequest = mockData.GetPARequest(id);
         if (paRequest is null) return null;

         var clinicalBundle = await fhirAggregator.AggregateClinicalDataAsync(
             paRequest.PatientId, cancellationToken: ct);

         var formData = await intelligenceClient.AnalyzeAsync(
             clinicalBundle, paRequest.ProcedureCode, ct);

         var criteria = formData.SupportingEvidence.Select(e => new CriterionModel
         {
             Met = e.Status switch
             {
                 "MET" => true,
                 "NOT_MET" => false,
                 _ => null
             },
             Label = e.CriterionId,
             Reason = e.Evidence
         }).ToList();

         var confidence = (int)(formData.ConfidenceScore * 100);

         return mockData.ApplyAnalysisResult(id,
             formData.ClinicalSummary, confidence, criteria);
     }
     ```

3. **[REFACTOR]** Extract evidence-to-criteria mapping to a static helper if mutation gets too long

---

### Task 8: Gateway — ProcessPARequest Error Handling
**Phase:** RED → GREEN
**Parallel Group:** D (sequential)
**Dependencies:** Task 7

1. **[RED]** Write error handling tests
   - File: `apps/gateway/Gateway.API.Tests/GraphQL/ProcessPARequestMutationTests.cs` (expand)
   - Tests:
     - `ProcessPARequest_WhenFhirAggregatorThrows_PropagatesException` — FHIR failure is not silently swallowed
     - `ProcessPARequest_WhenIntelligenceThrowsHttpRequestException_PropagatesException` — Intelligence service error propagates
     - `ProcessPARequest_WhenCancelled_ThrowsOperationCanceledException` — Cancellation is respected
   - Expected failure: Tests pass trivially if no error handling exists (need to verify exceptions propagate through GraphQL)

2. **[GREEN]** Add structured error handling
   - File: `apps/gateway/Gateway.API/GraphQL/Mutations/Mutation.cs`
   - Log errors with structured logging before re-throwing
   - Let Hot Chocolate's error filter handle the GraphQL error response
   - Consider: on Intelligence failure, fall back to `MockDataService.ProcessPARequestAsync()` as degraded mode?
     (Design doc doesn't specify — keep simple, just propagate for now)

3. **[REFACTOR]** Ensure error messages don't leak PHI in logs

---

### Task 9: Gateway — Integration Tests (Alba)
**Phase:** RED → GREEN
**Parallel Group:** E (after D merge)
**Dependencies:** Task 7

1. **[RED]** Create test bootstrap and integration tests
   - File: `apps/gateway/Gateway.API.Tests/Integration/ProcessPARequestAlbaBootstrap.cs`
     - Extends pattern from `EncounterProcessingAlbaBootstrap`
     - Mocks `IFhirDataAggregator` to return test `ClinicalBundle` (no Athena calls)
     - Mocks `IFhirTokenProvider` with test token
     - Configures `Intelligence:BaseUrl` to point to a mock HTTP endpoint (use `TestServer` or `WireMock.Net`)
     - Uses in-memory database

   - File: `apps/gateway/Gateway.API.Tests/Integration/ProcessPARequestIntegrationTests.cs`
   - Tests:
     - `ProcessPARequest_ViaGraphQL_ReturnsReadyStatusWithAnalysis` — Full GraphQL mutation through Alba, verify response has status="ready", real criteria, real confidence
     - `ProcessPARequest_ViaGraphQL_ClinicalSummaryIsNotStub` — Verify `clinicalSummary` doesn't contain "STUB"
     - `ProcessPARequest_ViaGraphQL_CriteriaHaveReasonableLabels` — Criteria labels come from Intelligence evidence, not random
   - Expected failure: Tests fail because IntelligenceClient mock HTTP server isn't set up

2. **[GREEN]** Wire up mock Intelligence HTTP server in bootstrap
   - Use `MockHttpMessageHandler` that returns canned `PAFormResponse` JSON
   - Register the mock handler in `ConfigureTestServices`
   - Verify full request/response cycle through GraphQL

3. **[REFACTOR]** Extract common mock response builders to shared test helpers

---

### Task 10: Dashboard — Component Tests for Real Data Shapes
**Phase:** RED → GREEN
**Parallel Group:** F (TypeScript worktree)
**Dependencies:** None

1. **[RED]** Expand component tests with real Intelligence response shapes
   - File: `apps/dashboard/src/components/__tests__/EvidencePanel.test.tsx` (expand)
   - Tests:
     - `EvidencePanel_WithIntelligenceEvidence_DisplaysCriterionIdAsLabel` — criterion_id like "conservative_therapy" renders as humanized label
     - `EvidencePanel_WithUnclearStatus_ShowsUnclearBadge` — UNCLEAR status renders differently from MET/NOT_MET
     - `EvidencePanel_WithSourceField_DisplaysSource` — Source from Intelligence evidence is shown

   - File: `apps/dashboard/src/components/__tests__/PARequestCard.test.tsx` (expand)
   - Tests:
     - `PARequestCard_WithRealConfidenceRange_DisplaysCorrectly` — Confidence values 0-100 from Intelligence render properly
     - `PARequestCard_WithAIClinicalSummary_DisplaysSummary` — Long AI-generated clinical summary renders without truncation issues

   - File: `apps/dashboard/src/api/__tests__/graphqlService.test.ts` (expand)
   - Tests:
     - `useProcessPARequest_InvalidatesCorrectQueries_OnSuccess` — After mutation, paRequests + paStats + activity queries are invalidated
   - Expected failure: Some tests may pass if component already handles these shapes; focus on gaps

2. **[GREEN]** Fix any rendering issues discovered by tests
   - Likely: humanize `criterion_id` strings (e.g., `conservative_therapy` → "Conservative Therapy")
   - Likely: handle `null` met values in criteria display

3. **[REFACTOR]** Extract test data builders for Intelligence-shaped data

---

## Delegation Plan

| Worktree | Tasks | Agent | Branch |
|----------|-------|-------|--------|
| Python Intelligence | 1, 2 | agent-intelligence | `feature/e2e-wiring/intelligence-generic-policy` |
| C# IntelligenceClient | 3, 4, 5 | agent-gateway-client | `feature/e2e-wiring/intelligence-client-http` |
| C# MockDataService | 6 | agent-gateway-mock | `feature/e2e-wiring/mockdata-analysis` |
| TS Dashboard | 10 | agent-dashboard | `feature/e2e-wiring/dashboard-tests` |
| C# Mutation (sequential) | 7, 8 | agent-gateway-mutation | `feature/e2e-wiring/mutation-wiring` |
| C# Integration (sequential) | 9 | agent-gateway-integration | `feature/e2e-wiring/integration-tests` |

**Wave 1 (parallel):** Tasks 1-6, 10
**Wave 2 (after merge):** Tasks 7, 8
**Wave 3 (after merge):** Task 9

## Verification Checklist

After all tasks complete:
- [ ] `cd apps/intelligence && python -m pytest src/tests/ -v` — All intelligence tests pass (including generic policy)
- [ ] `cd apps/gateway && dotnet test` — All gateway tests pass (including new IntelligenceClient + mutation tests)
- [ ] `cd apps/dashboard && npm test` — All dashboard tests pass
- [ ] Manual smoke test: Start all services via Aspire, create PA request in dashboard, click "Analyze", verify real AI analysis appears
