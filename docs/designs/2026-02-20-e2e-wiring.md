# End-to-End Wiring: Dashboard ↔ Gateway ↔ Intelligence

**Date:** 2026-02-20
**Feature ID:** `e2e-wiring`
**Status:** Draft

## Problem Statement

The three services (Dashboard, Gateway, Intelligence) work independently but are not wired end-to-end:

1. **Gateway `IntelligenceClient`** is a stub returning hardcoded mock data — never makes HTTP calls to the Intelligence service
2. **`ProcessPARequest` GraphQL mutation** bypasses Intelligence entirely — uses `MockDataService` with random confidence/criteria values
3. **Intelligence service** only supports 3 MRI Lumbar procedure codes (`72148`, `72149`, `72158`) — returns 400 for everything else

The `EncounterProcessor` already implements the correct pattern (FHIR → Intelligence → results), but the GraphQL mutation path doesn't use it.

## Architecture Context

```
Dashboard (React)          Gateway (.NET)                    Intelligence (Python)
┌─────────────┐    GraphQL    ┌──────────────────┐    HTTP/REST    ┌─────────────────┐
│ TanStack     │──────────────│ Mutation.cs       │                │ POST /analyze   │
│ React Query  │  /api/graphql│                   │                │                 │
│              │              │ MockDataService   │                │ Evidence        │
│ 5s polling   │              │   (in-memory)     │                │ Extractor (LLM) │
│              │              │                   │                │                 │
│              │              │ IntelligenceClient│── STUB ──X──── │ Form Generator  │
│              │              │   (returns mock)  │  (no HTTP)     │   (LLM)         │
│              │              │                   │                │                 │
│              │              │ FhirDataAggregator│────────────────│                 │
│              │              │   (Athena FHIR)   │  (working)     │                 │
└─────────────┘              └──────────────────┘                └─────────────────┘
     :5173                         :5000                              :8000
```

### What's already working:
- Dashboard → Gateway GraphQL: fully wired, real HTTP calls
- Gateway → Athena FHIR: `FhirDataAggregator` pulls real clinical data from sandbox (Practice 195900)
- Intelligence `/analyze` endpoint: LLM-powered evidence extraction + form generation
- `EncounterProcessor`: complete FHIR → Intelligence → PDF → notification pipeline
- Test patients 60178/60179/60180 match both MockDataService and Athena sandbox

### What's broken:
- `IntelligenceClient.AnalyzeAsync()` — stub, no HTTP
- `ProcessPARequest` mutation — doesn't call Intelligence at all
- Intelligence rejects non-MRI procedure codes with 400

## Design

### Seam 1: Real IntelligenceClient (HTTP)

Replace the stub `IntelligenceClient` with a real HTTP implementation that calls the Python service.

**File:** `apps/gateway/Gateway.API/Services/IntelligenceClient.cs`

Current (stub):
```csharp
public Task<PAFormData> AnalyzeAsync(ClinicalBundle bundle, string procedureCode, CancellationToken ct)
{
    // Returns hardcoded mock data
    return Task.FromResult(new PAFormData { ... });
}
```

Target:
```csharp
public sealed class IntelligenceClient : IIntelligenceClient
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<IntelligenceClient> _logger;

    public IntelligenceClient(HttpClient httpClient, ILogger<IntelligenceClient> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public async Task<PAFormData> AnalyzeAsync(
        ClinicalBundle bundle, string procedureCode, CancellationToken ct)
    {
        var request = BuildAnalyzeRequest(bundle, procedureCode);
        var response = await _httpClient.PostAsJsonAsync("/api/analyze", request, SnakeCaseOptions, ct);
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadFromJsonAsync<PAFormData>(SnakeCaseOptions, ct);
    }
}
```

**Key serialization concern:** Python expects snake_case keys (`patient_id`, `birth_date`, `member_id`). C# models use PascalCase. The `IntelligenceClient` must serialize with `JsonNamingPolicy.SnakeCaseLower` and build a request DTO that maps:
- `PatientInfo.FullName` → `clinical_data.patient.name`
- `PatientInfo.BirthDate` → `clinical_data.patient.birth_date`
- `PatientInfo.MemberId` → `clinical_data.patient.member_id`
- `ConditionInfo.Code/Display/ClinicalStatus` → `clinical_data.conditions[].code/display/clinical_status`

Note: `PAFormData` already has `[JsonPropertyName("snake_case")]` annotations, so deserialization is handled.

**DI wiring change** in `DependencyExtensions.AddIntelligenceClient()`:
```csharp
services.AddOptions<IntelligenceOptions>()
    .BindConfiguration(IntelligenceOptions.SectionName);

services.AddHttpClient<IIntelligenceClient, IntelligenceClient>()
    .ConfigureHttpClient((sp, client) =>
    {
        var options = sp.GetRequiredService<IOptions<IntelligenceOptions>>().Value;
        client.BaseAddress = new Uri(options.BaseUrl);
        client.Timeout = TimeSpan.FromSeconds(options.TimeoutSeconds);
    });
```

### Seam 2: Wire ProcessPARequest Through Real Pipeline

The `ProcessPARequest` GraphQL mutation needs to:
1. Look up the PA request from MockDataService (get patient ID, procedure code)
2. Aggregate real clinical data from Athena FHIR via `IFhirDataAggregator`
3. Call `IIntelligenceClient.AnalyzeAsync()` with the real bundle
4. Map `PAFormData` results back to `PARequestModel` (criteria, confidence, clinical summary)
5. Update the MockDataService record

**File:** `apps/gateway/Gateway.API/GraphQL/Mutations/Mutation.cs`

Current:
```csharp
public async Task<PARequestModel?> ProcessPARequest(string id, [Service] MockDataService mockData, CancellationToken ct)
{
    return await mockData.ProcessPARequestAsync(id, ct);  // Random values, 2s delay
}
```

Target:
```csharp
public async Task<PARequestModel?> ProcessPARequest(
    string id,
    [Service] MockDataService mockData,
    [Service] IFhirDataAggregator fhirAggregator,
    [Service] IIntelligenceClient intelligenceClient,
    CancellationToken ct)
{
    var paRequest = mockData.GetPARequest(id);
    if (paRequest is null) return null;

    // 1. Aggregate real clinical data from Athena FHIR
    var clinicalBundle = await fhirAggregator.AggregateClinicalDataAsync(
        paRequest.PatientId, cancellationToken: ct);

    // 2. Call Intelligence service
    var formData = await intelligenceClient.AnalyzeAsync(
        clinicalBundle, paRequest.ProcedureCode, ct);

    // 3. Map Intelligence response back to PA request model
    var criteria = formData.SupportingEvidence.Select(e => new CriterionModel
    {
        Met = e.Status == "MET" ? true : e.Status == "NOT_MET" ? false : null,
        Label = e.CriterionId,
        Reason = e.Evidence
    }).ToList();

    var confidence = (int)(formData.ConfidenceScore * 100);

    // 4. Update MockDataService record with real analysis
    return mockData.UpdatePARequest(id,
        clinicalSummary: formData.ClinicalSummary,
        criteria: criteria,
        status: "ready",
        confidence: confidence);
}
```

This follows the exact pattern from `EncounterProcessor.ProcessAsync()` (lines 67-113).

**MockDataService changes:** `ProcessPARequestAsync` needs a new overload or the `UpdatePARequest` method needs to accept `status` and `confidence` parameters. Current `UpdatePARequest` doesn't update status or confidence — add those fields.

### Seam 3: Intelligence — Graceful Procedure Code Handling

Currently Intelligence returns 400 for unsupported procedure codes. We need it to handle any procedure code gracefully.

**File:** `apps/intelligence/src/api/analyze.py`

**Approach:** Replace the hard-coded procedure validation with a generic policy fallback. When a procedure code doesn't have a specific policy, use a generic policy that:
- Evaluates medical necessity via LLM with the actual clinical data
- Validates diagnosis code presence
- Generates appropriate clinical summary
- Returns `MANUAL_REVIEW` recommendation for unrecognized procedures (lower confidence)

```python
# Remove the hard 400 rejection:
# if request.procedure_code not in SUPPORTED_PROCEDURE_CODES:
#     raise HTTPException(status_code=400, ...)

# Instead, load specific policy or fall back to generic:
if request.procedure_code in SPECIFIC_POLICIES:
    policy = SPECIFIC_POLICIES[request.procedure_code]
else:
    policy = build_generic_policy(request.procedure_code)
```

**New file:** `apps/intelligence/src/policies/generic_policy.py` — defines a generic policy template that works for any procedure code, with criteria focused on:
- Medical necessity documented
- Valid diagnosis code present
- Conservative therapy attempted (if applicable)

### Seam 4: ClinicalBundle Serialization Bridge

The C# `ClinicalBundle` model structure doesn't directly map to what the Python `ClinicalBundle.from_dict()` expects. Create a request DTO in the IntelligenceClient that bridges this gap.

**Key mappings:**
| C# (Gateway) | Python (Intelligence) |
|---|---|
| `PatientInfo.FullName` | `patient.name` |
| `PatientInfo.BirthDate` (DateOnly) | `patient.birth_date` (ISO string) |
| `PatientInfo.Gender` | `patient.gender` |
| `PatientInfo.MemberId` | `patient.member_id` |
| `ConditionInfo.Code` | `conditions[].code` |
| `ConditionInfo.CodeSystem` | `conditions[].system` |
| `ConditionInfo.Display` | `conditions[].display` |
| `ConditionInfo.ClinicalStatus` | `conditions[].clinical_status` |
| `ObservationInfo.Code/Display/Value/Unit` | `observations[].code/display/value/unit` |
| `ProcedureInfo.Code/Display/Status` | `procedures[].code/display/status` |
| `List<DocumentInfo>` | `document_texts: list[str]` (extract text) |

Create an internal `AnalyzeRequestDto` record in the IntelligenceClient that handles this mapping, serialized with `JsonNamingPolicy.SnakeCaseLower`.

## Testing Strategy

### Layer 1: Gateway Integration Tests (C# — TUnit + Alba)

Test the full GraphQL mutation → Intelligence pipeline with a mock Intelligence HTTP server.

**New test file:** `apps/gateway/Gateway.API.Tests/Integration/ProcessPARequestIntegrationTests.cs`

Tests:
- `ProcessPARequest_WithValidPatient_CallsIntelligenceAndReturnsAnalysis` — Verify the mutation calls Intelligence HTTP endpoint with correct request shape, maps response to PARequestModel
- `ProcessPARequest_WhenIntelligenceReturnsApprove_SetsReadyStatusAndHighConfidence`
- `ProcessPARequest_WhenIntelligenceReturnsManualReview_SetsReadyStatusAndLowerConfidence`
- `ProcessPARequest_WhenIntelligenceTimesOut_ReturnsError`
- `ProcessPARequest_WhenFhirFails_ReturnsError`

**Mock strategy:** Use `WireMock.Net` or a simple `TestServer` to mock Intelligence HTTP responses. Use NSubstitute for `IFhirDataAggregator` to return test clinical bundles without hitting Athena.

**New test file:** `apps/gateway/Gateway.API.Tests/Integration/IntelligenceClientIntegrationTests.cs`

Tests:
- `AnalyzeAsync_SerializesRequestWithSnakeCaseKeys` — Verify JSON payload matches Python expectations
- `AnalyzeAsync_DeserializesResponseCorrectly` — Verify PAFormData mapping from snake_case response
- `AnalyzeAsync_WhenServiceReturns400_ThrowsHttpRequestException`
- `AnalyzeAsync_WhenServiceTimesOut_ThrowsTaskCanceledException`

### Layer 2: Intelligence Component Tests (Python — pytest)

Expand test coverage for the new generic policy path.

**Expanded test file:** `apps/intelligence/src/tests/test_analyze.py`

Tests:
- `test_analyze_unsupported_procedure_uses_generic_policy` — Verify 27447 (TKR) doesn't 400 anymore
- `test_analyze_generic_policy_returns_manual_review` — Verify recommendation is MANUAL_REVIEW for unknown procedures
- `test_analyze_generic_policy_includes_evidence` — Verify evidence extraction still runs
- `test_analyze_known_procedure_uses_specific_policy` — Verify 72148 still uses MRI policy

### Layer 3: E2E Integration Tests (cross-service)

**New test file:** `apps/gateway/Gateway.API.Tests/E2E/EndToEndAnalysisTests.cs`

These tests require both Gateway and Intelligence services running (CI docker-compose or Aspire).

Tests:
- `ProcessPARequest_EndToEnd_WithAthenaPatient60178` — Full pipeline: GraphQL mutation → FHIR aggregation (Athena sandbox) → Intelligence analysis → response with real clinical summary and evidence
- `ProcessPARequest_EndToEnd_WithMRIProcedure_ReturnsApproveRecommendation`
- `ProcessPARequest_EndToEnd_WithSurgeryProcedure_ReturnsManualReviewRecommendation`

**Environment:** These tests are tagged `[E2E]` and run in CI with docker-compose bringing up Intelligence + mock FHIR (or real Athena sandbox with credentials).

### Layer 4: Dashboard Component Tests (TypeScript — Vitest)

Verify the dashboard correctly renders real analysis data shapes (not just mock shapes).

**Expanded test files:**
- `apps/dashboard/src/components/__tests__/EvidencePanel.test.tsx` — Test with real evidence shapes (criterion_id-based labels, varying confidence)
- `apps/dashboard/src/components/__tests__/PARequestCard.test.tsx` — Test confidence display from real 0-100 values
- `apps/dashboard/src/api/__tests__/graphqlService.test.ts` — Verify query/mutation contracts match updated gateway schema

## Data Flow (Target State)

```
User clicks "Analyze"
        │
        ▼
Dashboard: useProcessPARequest(id)
        │ GraphQL mutation
        ▼
Gateway: Mutation.ProcessPARequest(id)
        │
        ├─► MockDataService.GetPARequest(id)  →  get patientId, procedureCode
        │
        ├─► FhirDataAggregator.AggregateClinicalDataAsync(patientId)
        │       │
        │       └─► Athena FHIR R4 API (Practice 195900)
        │           ├─ GET Patient/60178
        │           ├─ GET Condition?patient=60178
        │           ├─ GET Observation?patient=60178
        │           ├─ GET Procedure?patient=60178
        │           └─ GET DocumentReference?patient=60178
        │       ◄── ClinicalBundle (real patient data)
        │
        ├─► IntelligenceClient.AnalyzeAsync(bundle, procedureCode)
        │       │
        │       └─► POST http://intelligence:8000/api/analyze
        │           {
        │             "patient_id": "60178",
        │             "procedure_code": "72148",
        │             "clinical_data": { real FHIR bundle }
        │           }
        │       ◄── PAFormResponse (LLM analysis)
        │
        ├─► Map PAFormResponse → PARequestModel
        │   - Evidence items → Criteria (MET/NOT_MET/UNCLEAR)
        │   - ConfidenceScore → Confidence (0-100)
        │   - ClinicalSummary → ClinicalSummary
        │   - Status → "ready"
        │
        └─► MockDataService.UpdatePARequest(id, ...)
                │
                ▼
        Dashboard receives updated PARequestModel via query invalidation
```

## File Change Summary

### Gateway (C#)

| File | Change |
|------|--------|
| `Services/IntelligenceClient.cs` | Replace stub with real HttpClient implementation |
| `DependencyExtensions.cs` | Wire `AddHttpClient<IIntelligenceClient>` with `IntelligenceOptions` |
| `GraphQL/Mutations/Mutation.cs` | Wire `ProcessPARequest` through FHIR + Intelligence pipeline |
| `Services/MockDataService.cs` | Add status/confidence params to `UpdatePARequest` or add new method for analysis results |

### Intelligence (Python)

| File | Change |
|------|--------|
| `api/analyze.py` | Remove hard 400 rejection; use generic policy fallback |
| `policies/generic_policy.py` | New — generic policy for any procedure code |

### Tests

| File | Change |
|------|--------|
| `Gateway.API.Tests/Integration/ProcessPARequestIntegrationTests.cs` | New — mutation → Intelligence pipeline tests |
| `Gateway.API.Tests/Integration/IntelligenceClientIntegrationTests.cs` | New — HTTP serialization/deserialization tests |
| `Gateway.API.Tests/E2E/EndToEndAnalysisTests.cs` | New — full-stack E2E tests |
| `intelligence/src/tests/test_analyze.py` | Expand — generic policy tests |
| Dashboard component tests | Expand — real data shape tests |

## Risks & Mitigations

| Risk | Mitigation |
|------|-----------|
| Athena sandbox rate limits during tests | Use `IFhirDataAggregator` mock in unit/integration tests; real Athena only in E2E |
| LLM latency in Intelligence (~5-15s) | Gateway already has 30s timeout; add loading state in dashboard |
| ClinicalBundle serialization mismatch | Integration tests explicitly validate JSON shape matches Python expectations |
| MockDataService thread-safety with async FHIR/Intelligence calls | Existing lock mechanism is sufficient; async work happens outside locks |
