/**
 * Generated by orval v7.20.0 ðŸº
 * Do not edit manually.
 * AuthScript Intelligence Service
 * Clinical reasoning engine for prior authorization.

## Features
- Evidence Extraction: Analyzes clinical data against policy criteria
- Form Generation: Populates PA form fields with extracted evidence
- Multi-Provider LLM: Supports GitHub, Azure, Gemini, OpenAI
    
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import type {
  AnalyzeRequest,
  AnalyzeWithDocumentsAnalyzeWithDocumentsPostParams,
  BodyAnalyzeWithDocumentsAnalyzeWithDocumentsPost,
  HTTPValidationError,
  PAFormResponse
} from '../intelligence.schemas';





/**
 * Analyze clinical data and generate PA form response.

Uses LLM to extract evidence from clinical data and generate PA form.
 * @summary Analyze
 */
export type analyzeAnalyzePostResponse200 = {
  data: PAFormResponse
  status: 200
}

export type analyzeAnalyzePostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type analyzeAnalyzePostResponseSuccess = (analyzeAnalyzePostResponse200) & {
  headers: Headers;
};
export type analyzeAnalyzePostResponseError = (analyzeAnalyzePostResponse422) & {
  headers: Headers;
};

export type analyzeAnalyzePostResponse = (analyzeAnalyzePostResponseSuccess | analyzeAnalyzePostResponseError)

export const getAnalyzeAnalyzePostUrl = () => {


  

  return `http://localhost:8000/analyze`
}

export const analyzeAnalyzePost = async (analyzeRequest: AnalyzeRequest, options?: RequestInit): Promise<analyzeAnalyzePostResponse> => {
  
  const res = await fetch(getAnalyzeAnalyzePostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      analyzeRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: analyzeAnalyzePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as analyzeAnalyzePostResponse
}




export const getAnalyzeAnalyzePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof analyzeAnalyzePost>>, TError,{data: AnalyzeRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof analyzeAnalyzePost>>, TError,{data: AnalyzeRequest}, TContext> => {

const mutationKey = ['analyzeAnalyzePost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof analyzeAnalyzePost>>, {data: AnalyzeRequest}> = (props) => {
          const {data} = props ?? {};

          return  analyzeAnalyzePost(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AnalyzeAnalyzePostMutationResult = NonNullable<Awaited<ReturnType<typeof analyzeAnalyzePost>>>
    export type AnalyzeAnalyzePostMutationBody = AnalyzeRequest
    export type AnalyzeAnalyzePostMutationError = HTTPValidationError

    /**
 * @summary Analyze
 */
export const useAnalyzeAnalyzePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof analyzeAnalyzePost>>, TError,{data: AnalyzeRequest}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof analyzeAnalyzePost>>,
        TError,
        {data: AnalyzeRequest},
        TContext
      > => {

      const mutationOptions = getAnalyzeAnalyzePostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Analyze clinical data with attached PDF documents.

Parses PDF documents and includes extracted text in the analysis.
 * @summary Analyze With Documents
 */
export type analyzeWithDocumentsAnalyzeWithDocumentsPostResponse200 = {
  data: PAFormResponse
  status: 200
}

export type analyzeWithDocumentsAnalyzeWithDocumentsPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type analyzeWithDocumentsAnalyzeWithDocumentsPostResponseSuccess = (analyzeWithDocumentsAnalyzeWithDocumentsPostResponse200) & {
  headers: Headers;
};
export type analyzeWithDocumentsAnalyzeWithDocumentsPostResponseError = (analyzeWithDocumentsAnalyzeWithDocumentsPostResponse422) & {
  headers: Headers;
};

export type analyzeWithDocumentsAnalyzeWithDocumentsPostResponse = (analyzeWithDocumentsAnalyzeWithDocumentsPostResponseSuccess | analyzeWithDocumentsAnalyzeWithDocumentsPostResponseError)

export const getAnalyzeWithDocumentsAnalyzeWithDocumentsPostUrl = (params: AnalyzeWithDocumentsAnalyzeWithDocumentsPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/analyze/with-documents?${stringifiedParams}` : `http://localhost:8000/analyze/with-documents`
}

export const analyzeWithDocumentsAnalyzeWithDocumentsPost = async (bodyAnalyzeWithDocumentsAnalyzeWithDocumentsPost: BodyAnalyzeWithDocumentsAnalyzeWithDocumentsPost,
    params: AnalyzeWithDocumentsAnalyzeWithDocumentsPostParams, options?: RequestInit): Promise<analyzeWithDocumentsAnalyzeWithDocumentsPostResponse> => {
    const formData = new FormData();
if(bodyAnalyzeWithDocumentsAnalyzeWithDocumentsPost.documents !== undefined) {
 bodyAnalyzeWithDocumentsAnalyzeWithDocumentsPost.documents.forEach(value => formData.append(`documents`, value));
 }

  const res = await fetch(getAnalyzeWithDocumentsAnalyzeWithDocumentsPostUrl(params),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: analyzeWithDocumentsAnalyzeWithDocumentsPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as analyzeWithDocumentsAnalyzeWithDocumentsPostResponse
}




export const getAnalyzeWithDocumentsAnalyzeWithDocumentsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof analyzeWithDocumentsAnalyzeWithDocumentsPost>>, TError,{data: BodyAnalyzeWithDocumentsAnalyzeWithDocumentsPost;params: AnalyzeWithDocumentsAnalyzeWithDocumentsPostParams}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof analyzeWithDocumentsAnalyzeWithDocumentsPost>>, TError,{data: BodyAnalyzeWithDocumentsAnalyzeWithDocumentsPost;params: AnalyzeWithDocumentsAnalyzeWithDocumentsPostParams}, TContext> => {

const mutationKey = ['analyzeWithDocumentsAnalyzeWithDocumentsPost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof analyzeWithDocumentsAnalyzeWithDocumentsPost>>, {data: BodyAnalyzeWithDocumentsAnalyzeWithDocumentsPost;params: AnalyzeWithDocumentsAnalyzeWithDocumentsPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  analyzeWithDocumentsAnalyzeWithDocumentsPost(data,params,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AnalyzeWithDocumentsAnalyzeWithDocumentsPostMutationResult = NonNullable<Awaited<ReturnType<typeof analyzeWithDocumentsAnalyzeWithDocumentsPost>>>
    export type AnalyzeWithDocumentsAnalyzeWithDocumentsPostMutationBody = BodyAnalyzeWithDocumentsAnalyzeWithDocumentsPost
    export type AnalyzeWithDocumentsAnalyzeWithDocumentsPostMutationError = HTTPValidationError

    /**
 * @summary Analyze With Documents
 */
export const useAnalyzeWithDocumentsAnalyzeWithDocumentsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof analyzeWithDocumentsAnalyzeWithDocumentsPost>>, TError,{data: BodyAnalyzeWithDocumentsAnalyzeWithDocumentsPost;params: AnalyzeWithDocumentsAnalyzeWithDocumentsPostParams}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof analyzeWithDocumentsAnalyzeWithDocumentsPost>>,
        TError,
        {data: BodyAnalyzeWithDocumentsAnalyzeWithDocumentsPost;params: AnalyzeWithDocumentsAnalyzeWithDocumentsPostParams},
        TContext
      > => {

      const mutationOptions = getAnalyzeWithDocumentsAnalyzeWithDocumentsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    