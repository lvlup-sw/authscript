/**
 * Generated by orval v7.20.0 ðŸº
 * Do not edit manually.
 * AuthScript Intelligence Service
 * Clinical reasoning engine for prior authorization.

## Features
- Evidence Extraction: Analyzes clinical data against policy criteria
- Form Generation: Populates PA form fields with extracted evidence
- Multi-Provider LLM: Supports GitHub, Azure, Gemini, OpenAI
    
 * OpenAPI spec version: 0.1.0
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  QueryFunction,
  QueryKey,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HealthCheckHealthGet200,
  RootGet200
} from '../intelligence.schemas';





/**
 * Health check endpoint for Aspire orchestration.
 * @summary Health Check
 */
export type healthCheckHealthGetResponse200 = {
  data: HealthCheckHealthGet200
  status: 200
}
    
export type healthCheckHealthGetResponseSuccess = (healthCheckHealthGetResponse200) & {
  headers: Headers;
};
;

export type healthCheckHealthGetResponse = (healthCheckHealthGetResponseSuccess)

export const getHealthCheckHealthGetUrl = () => {


  

  return `http://localhost:8000/health`
}

export const healthCheckHealthGet = async ( options?: RequestInit): Promise<healthCheckHealthGetResponse> => {
  
  const res = await fetch(getHealthCheckHealthGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: healthCheckHealthGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as healthCheckHealthGetResponse
}





export const getHealthCheckHealthGetQueryKey = () => {
    return [
    `http://localhost:8000/health`
    ] as const;
    }

    
export const getHealthCheckHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckHealthGet>>> = ({ signal }) => healthCheckHealthGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData> & { queryKey: QueryKey }
}

export type HealthCheckHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckHealthGet>>>
export type HealthCheckHealthGetQueryError = unknown


/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getHealthCheckHealthGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Root endpoint with service information.
 * @summary Root
 */
export type rootGetResponse200 = {
  data: RootGet200
  status: 200
}
    
export type rootGetResponseSuccess = (rootGetResponse200) & {
  headers: Headers;
};
;

export type rootGetResponse = (rootGetResponseSuccess)

export const getRootGetUrl = () => {


  

  return `http://localhost:8000/`
}

export const rootGet = async ( options?: RequestInit): Promise<rootGetResponse> => {
  
  const res = await fetch(getRootGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: rootGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as rootGetResponse
}





export const getRootGetQueryKey = () => {
    return [
    `http://localhost:8000/`
    ] as const;
    }

    
export const getRootGetQueryOptions = <TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({ signal }) => rootGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & { queryKey: QueryKey }
}

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = unknown


/**
 * @summary Root
 */

export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getRootGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




